
수업할 내용
while 

 

생성자

메소드 호출 반복

super , this , toString 

배열

과제 풀이



main  static 관련 



===================
실습문제 완성하기 

못하겠으면 어디까지 했는데 이후는 못해서 언제까지 할게요~ 라고 올려라

오늘한것 정리하기

===============

this( ) 는 자기자신(현재클래스) 생성자를 호출할때 사용하는것

super( ) 는 부모클래스 생성자를 호출할때 사용하는것

this. ~ 은 나를 호출 한 인스턴스를 호출하는것, 위치(주소)표현, 인스턴스를 참조하고 있는것
            (내가 가지고 있는걸 가지고 오고 싶을때)
super. ~ 은 상위클래스의 인스턴스를 호출하는것
	(부모가 가지고 있는걸 가지고 오고 싶을때)

메소드들은 자기를 호출한게 누구인지 알고있다
우리가 쓰지 않아도 멤버변수에는 this.이 생략되어서 존재한다(우리가 눈으로 볼 수는 없다)
int = a; ==> this.int = this.a;
this 는 주소를 기억한다
static에서는 this를 쓸 수가 없다 static은 인스턴스가 만들어지기 전에 메모리주소값을 선점하니까

this와 super는 첫번째 줄에 와야해서 둘 다 같이 못쓰니 
this와 super를 둘 다 쓰고싶으면 일반메소드를 만들어서 생성자에서 일반 메소드를 호출하게 만들어준다
중복적인 로직을 가지는 코드 구문이 나온다면 메소드화 시켜서 호출해서 사용하도록 만든다



toString() ==> overriding
toString()은
스트링화 시켜주는것중 한가지인데
~~.println(인스턴스를 써주면(래퍼런스 썻다는것과 같음)toString을 자동으로 호출한다);
이건 아무데서나 되는게 아니고 println의 성격임 



while(조건식 ){
     반복할 것
          전후로 빠져나갈 문장이 필요하다
} 
		
 for, while 빠져나갈때 break;

규칙적인 반복문은 for문 불규칙적인 반복문은 while문을 사용한다
for문은 언제까지 반복해~ 라고 하는것
while문은 어떤 조건이 될떄까지 반복해~ 라고 하는것



배열 
array
기본적인 배열은 모양,타입이 같다
아파트를 생각하면 편하다, 라인별로 타입이 같음
동일한 데이터 타입으로 연속된 공간을 할당시켜주는걸 배열이라고 한다.
배열의 칸은 0칸부터 시작하는데 시작주소로부터 얼마나 떨어져있는지를 세는게 원리이다
시작주소에 오는 값은 0만큼 떨어져 있으니 0이라고 하는것
ex) 
	성적처리할때 5명을 처리하고 싶다
	번호 5
	이름 5
	국어 5
	영어 5
	총점 5
	
	int num1;
	int num2;
	int num3;
	이런식으로 주택가처럼 하나씩 다 만들어줘야한다
	그래서 얘를 관리하기 쉽게하기 위해서 배열을 이용한다.
	모두 int 타입이니
	int[] nums; ==> 배열을 참조할 변수(여기서 nums는 배열의 시작주소다)
	int[] nums = new int[ 몇개 ~ 라는 수를 써준다];
	int[] nums = new int [28]; 이렇게 하면 28명 고정이다, 하지만 상황에 따라 바뀔 수 있을경우 28이 들어간 자리에 변수를 넣어주면 된다
	
	동일한 데이터 타입으로 연속된 공간을 할당시켜주는걸 배열이라고 한다.
	int[] nums = new int [28]; 배열의 칸은 0칸부터 시작하는데 시작주소로부터 얼마나 떨어져있는지를 세는게 원리이다 시작주소에 오는 값은 0만큼 떨어져 있으니 0이라고 하는것
	 
	nums[인덱스번호]=데이터;
		num1=45;
		num2=78;
		이렇게 인식한다
		nums[인덱스번호] 이게 변수이다 고로 배열은 변수의 집합이다.
		nums[28]=28; 방을 세칸짜리로 만들었을때 28번째에 28을넣어주고 싶다는거므로 범위를 벗어났다고 에러가 뜸
	
	변수명만으로 예를 들어보자
	class Test1{
		String name;
		String addr;
	}
	
	Test t1 = new Test1(); //int num1;
	Test t2 = new Test1(); //int num2; 라고 한것과 동일 / 원래는 위에껄 사용하려면 이렇게 사용을 했다
	
	Test1 [] ts = new Test1[ 2 ] ; //ts는 배열이 아니라 변수이고 ts가 참조하는게 배열이다 ==> 이걸 Test1타입으로 구성하고 있다 ==>
	ts[0]= new Test1(); 객체자료형은 이렇게 사용한다

